#include <mpi.h>
#include <stdio.h>
#include <stdlib.h>
#include <pthread.h>
#include <time.h>

#define REQ_TRZCINA 0
#define FREE_TRZCINA 1
#define CONF_TRZCINA 2
#define REQ_KWIAT 3
#define CONF_KWIAT 4
#define FREE_KWIAT 5
#define DELETE_LAST 6

typedef struct {
    int type;
    int sender_id;
    int bee_clock;
    int timestamp;
} Message;

typedef struct {
    int id_trzciny;
    int id_pszczoly;
    int liczba_jaj;
} Trzcina;

int P, K, T, N, Tlimit;
Trzcina *trzciny;
Message *request_queue, *sub_queue;
int local_clock;
int flowers_occupied = 0;

MPI_Datatype MPI_MyMessage;

pthread_mutex_t request_queue_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t clock_mutex = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t flowers_mutex = PTHREAD_MUTEX_INITIALIZER;

void create_mpi_message_type() {
    int lengths[4] = {1, 1, 1, 1};
    const MPI_Aint offsets[4] = {
        offsetof(Message, type),
        offsetof(Message, sender_id),
        offsetof(Message, bee_clock),
        offsetof(Message, timestamp)
    };
    MPI_Datatype types[4] = {MPI_INT, MPI_INT, MPI_INT, MPI_INT};
    MPI_Type_create_struct(4, lengths, offsets, types, &MPI_MyMessage);
    MPI_Type_commit(&MPI_MyMessage);
}

void send_message(int dest, Message msg) {
    MPI_Send(&msg, 1, MPI_MyMessage, dest, 0, MPI_COMM_WORLD);
}

void receive_message(int source, Message *msg) {
    MPI_Recv(msg, 1, MPI_MyMessage, source, 0, MPI_COMM_WORLD, MPI_STATUS_IGNORE);
}

int compare_messages(const void *a, const void *b) {
    Message *msgA = (Message *)a;
    Message *msgB = (Message *)b;

    if (msgA->bee_clock != msgB->bee_clock) {
        return msgA->bee_clock - msgB->bee_clock;
    }

    if (msgA->timestamp != msgB->timestamp) {
        return (msgA->timestamp < msgB->timestamp) ? -1 : 1;
    }

    return msgA->sender_id - msgB->sender_id;
}

void sort_request_queue() {
    
    qsort(request_queue, P, sizeof(Message), compare_messages);
    
}

void remove_oldest_request(int sender_id) {
    
    request_queue[sender_id].bee_clock = __INT_MAX__;
    
}

void initialize(int size) {
    P = size;
    K = 2;
    T = 3;
    N = 5;
    Tlimit = 15;

    trzciny = (Trzcina *)malloc(T * sizeof(Trzcina));
    for (int i = 0; i < T; i++) {
        trzciny[i].id_trzciny = i;
        trzciny[i].id_pszczoly = -1;
        trzciny[i].liczba_jaj = 0;
    }

    request_queue = (Message *)malloc(P * sizeof(Message));
    sub_queue = (Message *)malloc(P * sizeof(Message));

    local_clock = 0;
}

void bee_process(int bee_id) {
    MPI_Barrier(MPI_COMM_WORLD);
    while (N > 0) {

        for (int i = 0; i < T; i++) {
            printf("Pszczoła %d mówi: Trzcina %d: pszczola %d, jajka %d\n", bee_id, i, trzciny[i].id_pszczoly, trzciny[i].liczba_jaj);
        }
        
        local_clock = clock()%P;
        

        Message req_trzcina = {REQ_TRZCINA, bee_id, local_clock, 0};
        for (int i = 0; i < P; i++) {
            if (i != bee_id) {
                send_message(i, req_trzcina);
                local_clock++;
            }
        }

        
        request_queue[bee_id] = req_trzcina;
        
        // printf("Bee %d requested access to a reed\n", bee_id);

        int continu = 1;
        while (continu) {
            sort_request_queue();
            int support_count = 0;

            
            for (int i = 0; i < P; i++) {
                if (request_queue[i].type == REQ_TRZCINA) {
                    sub_queue[support_count] = request_queue[i];
                    support_count++;
                }
            }
            
            support_count = 0;

            for (int i = 0; i < T; i++) {
                if (sub_queue[i].sender_id == bee_id && 
                    sub_queue[i].type == REQ_TRZCINA &&
                    continu == 1) {
                    for (int j = 0; j < T; j++) {
                        if (trzciny[j].id_pszczoly == -1 &&
                            15 - trzciny[j].liczba_jaj >= N &&
                            continu == 1) {
                            trzciny[j].id_pszczoly = bee_id;
                            //printf("Bee %d gained access to a reed\n", bee_id);

                            Message conf_trzcina = {CONF_TRZCINA, bee_id, local_clock, j};
                            for (int i = 0; i < P; i++) {
                                send_message(i, conf_trzcina);
                                local_clock++;
                            }

                            continu = 0;
                            break;
                        }
                    }
                }
            }
        }
        //printf("Bee %d confirmed access to a reed\n", bee_id);

        Message delete_last = {DELETE_LAST, bee_id, local_clock, 0};
        for (int i = 0; i < P; i++) {
            send_message(i, delete_last);
            local_clock++;
        }
        

        while (N > 0) {
            // printf("Bee %d: eggs: %d\n", bee_id, N);

            Message req_kwiat = {REQ_KWIAT, bee_id, local_clock, 0};
            for (int i = 0; i < P; i++) {
                send_message(i, req_kwiat);
                local_clock++;
            }
            

            
            request_queue[bee_id] = req_kwiat;
            
            // printf("Bee %d requested access to a flower\n", bee_id);

            int support_count = 0;
            sort_request_queue();

            
            for (int i = 0; i < P; i++) {
                if (request_queue[i].type == REQ_KWIAT) {
                    sub_queue[support_count] = request_queue[i];
                    support_count++;
                }
            }
            

            int continu_kwiat = 1;
            while (continu_kwiat) {
                for (int i = 0; i < K; i++) {
                    if (sub_queue[i].sender_id == bee_id &&
                        sub_queue[i].type == REQ_KWIAT &&
                        continu_kwiat == 1) {
                        
                        if (flowers_occupied < K) {
                            Message conf_kwiat = {CONF_KWIAT, bee_id, local_clock, 0};
                            for (int i = 0; i < P; i++) {
                                send_message(i, conf_kwiat);
                                local_clock++;
                            }
                            flowers_occupied++;
                            
                            // printf("Bee %d gained access to a flower\n", bee_id);
                            continu_kwiat = 0;
                        }
                    }
                }
            }

            Message delete_last = {DELETE_LAST, bee_id, local_clock, 0};
            for (int i = 0; i < P; i++) {
                send_message(i, delete_last);
                local_clock++;
            }
            
            for (int i = 0; i < T; i++) {
                if (trzciny[i].id_pszczoly == bee_id) {
                    trzciny[i].liczba_jaj++;
                    N--;
                    // printf("Bee %d laid an egg\n", bee_id);
                    // printf("Debug - bee: %d, reed: %d, reed eggs: %d, flowers_occupied: %d\n", bee_id, i, trzciny[i].liczba_jaj, flowers_occupied);
                    break;
                }
            }

            Message free_kwiat = {FREE_KWIAT, bee_id, local_clock, 0};
            for (int i = 0; i < P; i++) {
                send_message(i, free_kwiat);
                local_clock++;
            }

            
            flowers_occupied--;
            
            // printf("Bee %d freed access to a flower\n", bee_id);

            // for (int i = 0; i < T; i++) {
            //     printf("Trzcina %d: pszczola %d, jajka %d\n", i, trzciny[i].id_pszczoly, trzciny[i].liczba_jaj);
            // }
        }

        Message free_trzcina = {FREE_TRZCINA, bee_id, local_clock, 0};
        for (int i = 0; i < P; i++) {
            send_message(i, free_trzcina);
            local_clock++;
        }
        printf("Bee %d freed access to a reed\n", bee_id);
    }
}

void handle_message(Message msg) {
    switch (msg.type) {
        case REQ_TRZCINA:
            
            request_queue[msg.sender_id] = msg;
            sort_request_queue();
            
            break;
        case DELETE_LAST:
            remove_oldest_request(msg.sender_id);
            break;
        case FREE_TRZCINA:
            for (int i = 0; i < T; i++) {
                if (trzciny[i].id_pszczoly == msg.sender_id) {
                    trzciny[i].id_pszczoly = -1;
                    trzciny[i].liczba_jaj += N;
                    printf("Bee %d left a reed\n", msg.sender_id);
                    break;
                }
            }
            break;
        case CONF_TRZCINA:
            trzciny[msg.timestamp].id_pszczoly = msg.sender_id;
            printf("Bee %d gained access to a reed %d\n", msg.sender_id, msg.timestamp);
            break;
        case REQ_KWIAT:
            
            request_queue[msg.sender_id] = msg;
            sort_request_queue();
            
            break;
        case CONF_KWIAT:
            
            flowers_occupied++;
            
            break;
        case FREE_KWIAT:
            
            flowers_occupied--;
            
            break;
    }
}

void *receive_messages(void *arg) {
    pthread_setcancelstate(PTHREAD_CANCEL_ENABLE, NULL);
    pthread_setcanceltype(PTHREAD_CANCEL_ASYNCHRONOUS, NULL);
    while (1) {
        Message msg;
        receive_message(MPI_ANY_SOURCE, &msg);
        handle_message(msg);
    }
    return NULL;
}

int main(int argc, char **argv) {
    int provided;
    MPI_Init_thread(&argc, &argv, MPI_THREAD_MULTIPLE, &provided);

    if (provided != MPI_THREAD_MULTIPLE) {
        fprintf(stderr, "Error initializing MPI\n");
        MPI_Abort(MPI_COMM_WORLD, 1);
    }

    int rank, size;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
    MPI_Comm_size(MPI_COMM_WORLD, &size);

    create_mpi_message_type();

    initialize(size);

    pthread_t receiver_thread;
    if (pthread_create(&receiver_thread, NULL, receive_messages, NULL) != 0) {
        fprintf(stderr, "Error creating thread\n");
        return 1;
    }

    if (rank < P) {
        printf("Process %d is a bee\n", rank);
        bee_process(rank);
        printf("Process %d is a bee no more\n", rank);
    }

    pthread_cancel(receiver_thread);

    if (pthread_join(receiver_thread, NULL) != 0) {
        fprintf(stderr, "Error joining thread\n");
        return 2;
    }

    MPI_Finalize();
    return 0;
}
